#include<Wire.h>
#define MPU 0x68
#define ACCLX 0x3B
#define ACCLY 0x3D
#define ACCLZ 0x3F
#define TEMP 0x41
#define GYROX 0x43
#define GYROY 0x45
#define GYROZ 0x47
#define PWR_MGMT_1      0x6B
#define SMPLRT_DIV_REG  0x19
#define CONFIG_REG      0x1A
#define GYRO_CONFIG     0x1B
#define ACCEL_CONFIG    0x1C
#define INT_STATUS      0x3A
#define ACCEL_XOUT_H    0x3B
#define USER_CTRL       0x6A      // FIFO and I2C Master control
#define FIFO_EN         0x23      // FIFO Enable register
#define FIFO_COUNTH     0x72      // FIFO Count High byte
#define FIFO_COUNTL     0x73      // FIFO Count Low byte
#define FIFO_R_W        0x74      // FIFO Read/Write register

// Scale factors for different ranges
#define ACCEL_SCALE_2G 16384.0    // LSB/g for ±2g range
#define ACCEL_SCALE_4G 8192.0     // LSB/g for ±4g range  
#define ACCEL_SCALE_8G 4096.0     // LSB/g for ±8g range
#define ACCEL_SCALE_16G 2048.0    // LSB/g for ±16g range

#define GYRO_SCALE_250 131.0      // LSB/(°/s) for ±250°/s range
#define GYRO_SCALE_500 65.5       // LSB/(°/s) for ±500°/s range
#define GYRO_SCALE_1000 32.8      // LSB/(°/s) for ±1000°/s range
#define GYRO_SCALE_2000 16.4      // LSB/(°/s) for ±2000°/s range

// Choose your scales (change these based on your range settings)
#define ACCEL_SCALE ACCEL_SCALE_2G  // Default ±2g
#define GYRO_SCALE GYRO_SCALE_250   // Default ±250°/s

#define NUM_BATCHES 2           // Number of batches to collect
#define BYTES_PER_BATCH 14      // Temp(2) + Gyro(6) + Accel(6) = 14 bytes
#define TOTAL_BYTES 28          // 2 batches × 14 bytes

// Structure to hold raw IMU data for one sample (all 7 sensors)
struct IMUData {
  int16_t Tp;  // Temperature
  int16_t Gx;  // Gyro X
  int16_t Gy;  // Gyro Y
  int16_t Gz;  // Gyro Z
  int16_t Ax;  // Accel X
  int16_t Ay;  // Accel Y
  int16_t Az;  // Accel Z
};

// Array to store 4 batches of IMU data using structures
IMUData imuData[NUM_BATCHES];

unsigned long startTime;
bool firstLoop = true;
unsigned long currentTime; 

void setup(){
  Serial.begin(115200); 
  Wire.begin();  // Initialize I2C bus
  
  // Wake up MPU6050
  dataWrite(PWR_MGMT_1, 0);
  delay(100);  // Give sensor time to stabilize
  
  // Configure for 200 Hz sampling rate
  
  // Enable FIFO
  
  // Enable all sensors to go into FIFO
}

void loop(){
  if (firstLoop) {
    startTime = millis();
    firstLoop = false;
  }

  // Check for overflow flag in INT_STATUS register
  uint8_t intStatus = Wire.read();
  
  // Check bit 4 for FIFO overflow
  if () {
    Serial.println("*** OVERFLOW PREVENTION: FIFO Overflow detected! Resetting FIFO ***");
    handleOverflow();
    return;  // Skip this loop iteration
  }
  // Get FIFO count
  
  // Process all available complete sets of batch
  while (fifoCount >= TOTAL_BYTES) {
    currentTime = millis() - startTime;
  
    // Read 28 bytes (2 samples)
    
    // Parse batch
    for (int i = 0; i < NUM_BATCHES; i++) {
      imuData[i].Ax = (Wire.read() << 8) | Wire.read();
    }
    
    // Variables to store averaged values
    float Ax_avg, Ay_avg, Az_avg, Gx_avg, Gy_avg, Gz_avg, Tp_avg;
    
    // Calculate averages using the function
    calAverage(Ax_avg, Ay_avg, Az_avg, Gx_avg, Gy_avg, Gz_avg, Tp_avg);
    
    // Print averaged data
    Serial.print(currentTime);
    Serial.print(",");
    Serial.print(Ax_avg, 4);
    Serial.print(",");
    Serial.print(Ay_avg, 4);
    Serial.print(",");
    Serial.print(Az_avg, 4);
    Serial.print(",");
    Serial.print(Gx_avg, 4);
    Serial.print(",");
    Serial.print(Gy_avg, 4);
    Serial.print(",");
    Serial.print(Gz_avg, 4);
    Serial.print(",");
    Serial.println(Tp_avg, 2);
    
    // Update FIFO count for next iteration
    fifoCount -= TOTAL_BYTES;

    //Delay to make FIFO overflow
    delay(50);
  }
}

// Function to calculate average for all sensors from imuData array
void calAverage(float &avgAx, float &avgAy, float &avgAz, 
                      float &avgGx, float &avgGy, float &avgGz, float &avgTp) {
  float sumAx = 0, sumAy = 0, sumAz = 0;
  float sumGx = 0, sumGy = 0, sumGz = 0;
  float sumTp = 0;
  
  // Sum all values for each sensor
  for (int i = 0; i < NUM_BATCHES; i++) {
    sumAx += imuData[i].Ax;
    sumAy += imuData[i].Ay;
    sumAz += imuData[i].Az;
    sumGx += imuData[i].Gx;
    sumGy += imuData[i].Gy;
    sumGz += imuData[i].Gz;
    sumTp += imuData[i].Tp;
  }
  
  // Calculate averages (still in raw values)
  float rawAvgAx = sumAx / NUM_BATCHES;
  float rawAvgAy = sumAy / NUM_BATCHES;
  float rawAvgAz = sumAz / NUM_BATCHES;
  float rawAvgGx = sumGx / NUM_BATCHES;
  float rawAvgGy = sumGy / NUM_BATCHES;
  float rawAvgGz = sumGz / NUM_BATCHES;
  float rawAvgTp = sumTp / NUM_BATCHES;
  
  // Convert to physical units
  avgAx = rawAvgAx / ACCEL_SCALE;  // g
  avgAy = rawAvgAy / ACCEL_SCALE;  // g
  avgAz = rawAvgAz / ACCEL_SCALE;  // g
  avgGx = rawAvgGx / GYRO_SCALE;   // degrees per second
  avgGy = rawAvgGy / GYRO_SCALE;   // degrees per second
  avgGz = rawAvgGz / GYRO_SCALE;   // degrees per second
  avgTp = (rawAvgTp / 340.0) + 36.53;  // Celsius
}

// Function to handle FIFO overflow
void handleOverflow() {
  // Disable FIFO and trigger reset (one step)
  
  // Re-enable FIFO

  // Reconfigure what goes into FIFO
  
  Serial.println("*** OVERFLOW PREVENTION: FIFO has been reset and re-enabled ***");
}

// Function to get FIFO count
uint16_t getFifoCount() {

}

void dataWrite(uint8_t REG, uint8_t val){
  Wire.beginTransmission(MPU);
  Wire.write(REG);
  Wire.write(val);
  Wire.endTransmission(true);
}
